/*
========================================================
        DATA STRUCTURES & ALGORITHMS (DSA) WITH C++
========================================================

--------------------------------------------------------
1. INTRODUCTION TO DSA
--------------------------------------------------------
Data Structures and Algorithms (DSA) is the study of
organizing data efficiently and designing designing algorithms
to solve problems optimally.

DSA helps in:
- Writing efficient programs
- Reducing time and memory usage
- Solving complex real-world problems
- Cracking technical interviews

--------------------------------------------------------
2. TIME & SPACE COMPLEXITY
--------------------------------------------------------
Time Complexity:
- Measures how execution time grows with input size.

Space Complexity:
- Measures extra memory used by an algorithm.

Notations:
- Big-O (Worst case)
- Big-Ω (Best case)
- Big-Θ (Average case)

Common Complexities:
O(1), O(log n), O(n), O(n log n), O(n²)

--------------------------------------------------------
3. ARRAYS
--------------------------------------------------------
- Linear data structure
- Stores homogeneous data
- Contiguous memory allocation
- 0-based indexing
- Fast access (O(1))

Operations:
- Traversal
- Insertion
- Deletion
- Searching
- Sorting

--------------------------------------------------------
4. STRINGS
--------------------------------------------------------
- Sequence of characters
- Indexed data structure
- Stored as char arrays or std::string

Operations:
- Length calculation
- Concatenation
- Comparison
- Substring
- Palindrome check
- Pattern matching

--------------------------------------------------------
5. RECURSION
--------------------------------------------------------
A function calling itself.

Components:
- Base case
- Recursive call

Types:
- Direct recursion
- Indirect recursion
- Tail recursion

Applications:
- Factorial
- Fibonacci
- Tree traversal
- Backtracking

--------------------------------------------------------
6. SEARCHING ALGORITHMS
--------------------------------------------------------
- Linear Search
- Binary Search
- Recursive Binary Search
- Search in rotated array

--------------------------------------------------------
7. SORTING ALGORITHMS
--------------------------------------------------------
Basic Sorting:
- Bubble Sort
- Selection Sort
- Insertion Sort

Advanced Sorting:
- Merge Sort
- Quick Sort
- Heap Sort

Non-Comparison Sorting:
- Counting Sort
- Radix Sort
- Bucket Sort

--------------------------------------------------------
8. LINKED LIST
--------------------------------------------------------
Types:
- Singly Linked List
- Doubly Linked List
- Circular Linked List

Operations:
- Insertion
- Deletion
- Traversal
- Reversal
- Loop detection

--------------------------------------------------------
9. STACK
--------------------------------------------------------
LIFO (Last In First Out)

Operations:
- Push
- Pop
- Peek

Applications:
- Expression evaluation
- Parenthesis checking
- Undo/Redo
- Function calls

--------------------------------------------------------
10. QUEUE
--------------------------------------------------------
FIFO (First In First Out)

Types:
- Simple Queue
- Circular Queue
- Deque
- Priority Queue

Applications:
- Scheduling
- BFS
- Resource management

--------------------------------------------------------
11. HASHING
--------------------------------------------------------
- Key-value based structure
- Fast lookup (average O(1))

Collision Handling:
- Chaining
- Open addressing

STL:
- unordered_map
- unordered_set

--------------------------------------------------------
12. TREES
--------------------------------------------------------
Hierarchical data structure.

Types:
- Binary Tree
- Binary Search Tree
- Balanced Trees

Traversals:
- Inorder
- Preorder
- Postorder
- Level Order

--------------------------------------------------------
13. HEAP
--------------------------------------------------------
Complete binary tree.

Types:
- Min Heap
- Max Heap

Applications:
- Heap Sort
- Priority Queue

--------------------------------------------------------
14. GRAPH
--------------------------------------------------------
Representation:
- Adjacency Matrix
- Adjacency List

Traversals:
- BFS
- DFS

Algorithms:
- Cycle detection
- Topological sort
- Shortest path

--------------------------------------------------------
15. GREEDY ALGORITHMS
--------------------------------------------------------
- Makes locally optimal choice

Examples:
- Activity Selection
- Fractional Knapsack
- Huffman Coding

--------------------------------------------------------
16. DYNAMIC PROGRAMMING
--------------------------------------------------------
Optimizes overlapping subproblems.

Techniques:
- Memoization (Top-down)
- Tabulation (Bottom-up)

Problems:
- Fibonacci
- Knapsack
- LCS
- LIS

--------------------------------------------------------
17. BACKTRACKING
--------------------------------------------------------
- Try all possibilities
- Undo previous steps

Problems:
- N-Queens
- Sudoku
- Rat in Maze

--------------------------------------------------------
18. BIT MANIPULATION
--------------------------------------------------------
- Binary representation
- AND, OR, XOR, NOT
- Bit masking
- Power of two check

--------------------------------------------------------
19. ADVANCED DATA STRUCTURES
--------------------------------------------------------
- Trie
- Segment Tree
- Fenwick Tree
- Disjoint Set
- AVL Tree
- Red-Black Tree

--------------------------------------------------------
20. STL IN DSA
--------------------------------------------------------
Containers:
- vector, list, deque
- stack, queue
- set, map
- unordered_map

Algorithms:
- sort
- find
- binary_search

--------------------------------------------------------
21. MATHEMATICAL ALGORITHMS
--------------------------------------------------------
- Prime numbers
- Sieve of Eratosthenes
- GCD / LCM
- Modular arithmetic
- Fast exponentiation

--------------------------------------------------------
22. PROBLEM SOLVING TECHNIQUES
--------------------------------------------------------
- Brute force
- Divide and Conquer
- Greedy
- Dynamic Programming
- Two-pointer
- Sliding window
- Binary search on answer

--------------------------------------------------------
23. REAL-WORLD APPLICATIONS
--------------------------------------------------------
- Search engines
- Databases
- Operating systems
- Networking
- Compilers
- Game engines

--------------------------------------------------------
24. SUMMARY
--------------------------------------------------------
DSA is essential for:
- Efficient programming
- Competitive coding
- Interviews
- System design foundations

========================================================
                END OF DSA NOTES
========================================================
*/
